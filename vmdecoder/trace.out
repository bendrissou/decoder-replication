parser >> Input 'FLOAT' in state 0
parser >> Shift 'FLOAT', pending reduce 50
parser >> Return. Stack=[FLOAT]
parser >> Input 'LPAREN' with pending reduce 50
parser >> Reduce 50 [type_specifier ::= FLOAT] without external action, pop back to state 0.
parser >> ... then shift 'type_specifier', go to state 78
parser >> Reduce 170 [declaration_specifiers ::= type_specifier] without external action, pop back to state 0.
parser >> ... then shift 'declaration_specifiers', go to state 92
parser >> Shift 'LPAREN', go to state 99
parser >> Return. Stack=[declaration_specifiers LPAREN]
parser >> Input 'LPAREN' in state 99
parser >> Shift 'LPAREN', go to state 99
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN]
parser >> Input 'LPAREN' in state 99
parser >> Shift 'LPAREN', go to state 99
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN LPAREN]
parser >> Input 'STAR' in state 99
parser >> Shift 'STAR', go to state 100
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN LPAREN STAR]
parser >> Input 'STAR' in state 100
parser >> Shift 'STAR', go to state 100
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN LPAREN STAR STAR]
parser >> Input 'CONST' in state 100
parser >> Shift 'CONST', pending reduce 55
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN LPAREN STAR STAR CONST]
parser >> Input 'NAME' with pending reduce 55
parser >> Reduce 55 [type_qualifier ::= CONST] without external action, pop back to state 100.
parser >> ... then shift 'type_qualifier', go to state 102
parser >> Reduce 59 [pointer ::= STAR type_qualifier_list] without external action, pop back to state 100.
parser >> ... then shift 'pointer', pending reduce 62
parser >> Reduce 62 [pointer ::= STAR pointer] without external action, pop back to state 99.
parser >> ... then shift 'pointer', go to state 106
parser >> Shift 'NAME', pending reduce 0
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN LPAREN pointer NAME]
parser >> Input 'RPAREN' with pending reduce 0
parser >> Reduce 0 [direct_declarator ::= NAME], pop back to state 106.
parser >> ... then shift 'direct_declarator', go to state 137
parser >> Reduce 204 [declarator ::= pointer direct_declarator] without external action, pop back to state 99.
parser >> ... then shift 'declarator', go to state 176
parser >> Shift 'RPAREN', pending reduce 198
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN LPAREN declarator RPAREN]
parser >> Input 'LPAREN' with pending reduce 198
parser >> Reduce 198 [direct_declarator ::= LPAREN declarator RPAREN] without external action, pop back to state 99.
parser >> ... then shift 'direct_declarator', go to state 135
parser >> Shift 'LPAREN', go to state 58
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LPAREN]
parser >> Input 'NAME' in state 58
parser >> Shift 'NAME', pending reduce 161
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LPAREN NAME]
parser >> Input 'COMMA' with pending reduce 161
parser >> Reduce 161 [identifier_list ::= NAME] without external action, pop back to state 58.
parser >> ... then shift 'identifier_list', go to state 136
parser >> Shift 'COMMA', go to state 178
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LPAREN identifier_list COMMA]
parser >> Input 'NAME' in state 178
parser >> Shift 'NAME', pending reduce 162
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LPAREN identifier_list COMMA NAME]
parser >> Input 'RPAREN' with pending reduce 162
parser >> Reduce 162 [identifier_list ::= identifier_list COMMA NAME] without external action, pop back to state 58.
parser >> ... then shift 'identifier_list', go to state 136
parser >> Shift 'RPAREN', pending reduce 202
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LPAREN identifier_list RPAREN]
parser >> Input 'LBRACKET' with pending reduce 202
parser >> Reduce 202 [direct_declarator ::= direct_declarator LPAREN identifier_list RPAREN] without external action, pop back to state 99.
parser >> ... then shift 'direct_declarator', go to state 135
parser >> Shift 'LBRACKET', go to state 41
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LBRACKET]
parser >> Input 'STRING_LITERAL' in state 41
parser >> Shift 'STRING_LITERAL', pending reduce 73
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LBRACKET STRING_LITERAL]
parser >> Input 'RBRACKET' with pending reduce 73
parser >> Reduce 73 [primary_expression ::= STRING_LITERAL] without external action, pop back to state 41.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 41.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 41.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 41.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 41.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 41.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 41.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 41.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 41.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 41.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 41.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 41.
parser >> ... then shift 'conditional_expression', go to state 179
parser >> Shift 'RBRACKET', pending reduce 199
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN direct_declarator LBRACKET conditional_expression RBRACKET]
parser >> Input 'RPAREN' with pending reduce 199
parser >> Reduce 199 [direct_declarator ::= direct_declarator LBRACKET constant_expression RBRACKET] without external action, pop back to state 99.
parser >> ... then shift 'direct_declarator', go to state 135
parser >> Reduce 203 [declarator ::= direct_declarator] without external action, pop back to state 99.
parser >> ... then shift 'declarator', go to state 176
parser >> Shift 'RPAREN', pending reduce 198
parser >> Return. Stack=[declaration_specifiers LPAREN LPAREN declarator RPAREN]
parser >> Input 'RPAREN' with pending reduce 198
parser >> Reduce 198 [direct_declarator ::= LPAREN declarator RPAREN] without external action, pop back to state 99.
parser >> ... then shift 'direct_declarator', go to state 135
parser >> Reduce 203 [declarator ::= direct_declarator] without external action, pop back to state 99.
parser >> ... then shift 'declarator', go to state 176
parser >> Shift 'RPAREN', pending reduce 198
parser >> Return. Stack=[declaration_specifiers LPAREN declarator RPAREN]
parser >> Input 'LBRACKET' with pending reduce 198
parser >> Reduce 198 [direct_declarator ::= LPAREN declarator RPAREN] without external action, pop back to state 92.
parser >> ... then shift 'direct_declarator', go to state 135
parser >> Shift 'LBRACKET', go to state 41
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET]
parser >> Input 'LPAREN' in state 41
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION]
parser >> Input 'NOT' in state 38
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION NOT]
parser >> Input 'AND' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 38.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION unary_operator AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION unary_operator unary_operator INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION cast_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION cast_expression DIV INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION cast_expression DIV primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION cast_expression DIV primary_expression LBRACKET INT_LITERAL]
parser >> Input 'RBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'conditional_expression', go to state 153
parser >> Shift 'RBRACKET', pending reduce 76
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION cast_expression DIV primary_expression LBRACKET conditional_expression RBRACKET]
parser >> Input 'COMMA' with pending reduce 76
parser >> Reduce 76 [postfix_expression ::= postfix_expression LBRACKET expression RBRACKET] without external action, pop back to state 88.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'conditional_expression', go to state 140
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA]
parser >> Input 'SUB' in state 48
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 48.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA unary_operator INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 48.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 48.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 48.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT INT_LITERAL]
parser >> Input 'COLON' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 48.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 48.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 48.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'conditional_expression', pending reduce 124
parser >> Reduce 124 [expression ::= expression COMMA assignment_expression] without external action, pop back to state 38.
parser >> ... then shift 'expression', go to state 140
parser >> Shift 'COLON', go to state 51
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION expression COLON]
parser >> Input 'INT_LITERAL' in state 51
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN logical_or_expression QUESTION expression COLON INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 51.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 51.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 51.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 51.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 51.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 51.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 51.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 51.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 51.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 51.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 51.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 51.
parser >> ... then shift 'conditional_expression', pending reduce 120
parser >> Reduce 120 [conditional_expression ::= logical_or_expression QUESTION expression COLON conditional_expression] without external action, pop back to state 4.
parser >> ... then shift 'conditional_expression', go to state 152
parser >> Shift 'RPAREN', pending reduce 74
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET LPAREN conditional_expression RPAREN]
parser >> Input 'LPAREN' with pending reduce 74
parser >> Reduce 74 [primary_expression ::= LPAREN expression RPAREN] without external action, pop back to state 41.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN]
parser >> Input 'NOT' in state 33
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 33.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN unary_operator INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT]
parser >> Input 'LPAREN' in state 75
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN]
parser >> Input 'SUB' in state 4
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 4.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN]
parser >> Input 'SUB' in state 33
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 33.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN unary_operator INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN and_expression AND]
parser >> Input 'INT_LITERAL' in state 64
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN and_expression AND INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 64.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN and_expression AND additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN and_expression AND additive_expression ADD INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'COMMA', go to state 46
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA]
parser >> Input 'AND' in state 46
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 46.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA unary_operator INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 46.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 46.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 46.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 46.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 46.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 46.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ]
parser >> Input 'AND' in state 67
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ unary_operator INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ relational_expression GT INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 46.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 46.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 46.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN]
parser >> Input 'INT_LITERAL' in state 33
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET]
parser >> Input 'TILDE' in state 40
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 40.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND]
parser >> Input 'AND' in state 64
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND AND]
parser >> Input 'SUB' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND unary_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND unary_operator unary_operator INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression GT INT_LITERAL]
parser >> Input 'LT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'LT', go to state 76
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT]
parser >> Input 'TILDE' in state 76
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT TILDE]
parser >> Input 'AND' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 76.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator AND]
parser >> Input 'LPAREN' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN INT_LITERAL]
parser >> Input 'OREQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'OREQ', pending reduce 21
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression OREQ]
parser >> Input 'INT_LITERAL' with pending reduce 21
parser >> Reduce 21 [assignment_operator ::= OREQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 47.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 47.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator relational_expression GT INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 47.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator and_expression AND]
parser >> Input 'INT_LITERAL' in state 64
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator and_expression AND INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 64.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator and_expression AND equality_expression NOTEQ]
parser >> Input 'NOT' in state 67
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator and_expression AND equality_expression NOTEQ NOT]
parser >> Input 'SUB' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator and_expression AND equality_expression NOTEQ unary_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN unary_expression assignment_operator and_expression AND equality_expression NOTEQ unary_operator unary_operator INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 47.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 47.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'conditional_expression', pending reduce 122
parser >> Reduce 122 [assignment_expression ::= unary_expression assignment_operator assignment_expression] without external action, pop back to state 4.
parser >> ... then shift 'assignment_expression', go to state 152
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN assignment_expression COMMA]
parser >> Input 'INT_LITERAL' in state 48
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN assignment_expression COMMA INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 48.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 48.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 48.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 48.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 48.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 48.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 48.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'conditional_expression', pending reduce 124
parser >> Reduce 124 [expression ::= expression COMMA assignment_expression] without external action, pop back to state 4.
parser >> ... then shift 'expression', go to state 152
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA]
parser >> Input 'NOT' in state 48
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 48.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_operator INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 48.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA cast_expression STAR]
parser >> Input 'INT_LITERAL' in state 89
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA cast_expression STAR INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 89.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 48.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 48.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 48.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 48.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 48.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 48.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'conditional_expression', pending reduce 124
parser >> Reduce 124 [expression ::= expression COMMA assignment_expression] without external action, pop back to state 4.
parser >> ... then shift 'expression', go to state 152
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA]
parser >> Input 'INT_LITERAL' in state 48
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA INT_LITERAL]
parser >> Input 'EQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 48.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'EQ', pending reduce 11
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression EQ]
parser >> Input 'AND' with pending reduce 11
parser >> Reduce 11 [assignment_operator ::= EQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator AND]
parser >> Input 'STAR' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 47.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator unary_operator STAR]
parser >> Input 'TILDE' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator unary_operator unary_operator TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator unary_operator unary_operator unary_operator INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 47.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ]
parser >> Input 'LPAREN' in state 67
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN cast_expression STAR]
parser >> Input 'NOT' in state 89
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN cast_expression STAR NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN cast_expression STAR unary_operator INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 4.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET]
parser >> Input 'TILDE' in state 40
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 40.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET unary_operator INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN]
parser >> Input 'STAR' in state 33
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 33.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN unary_operator INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR]
parser >> Input 'LPAREN' in state 57
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN]
parser >> Input 'STAR' in state 4
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN STAR]
parser >> Input 'NOT' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 4.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator NOT]
parser >> Input 'STAR' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator STAR]
parser >> Input 'NOT' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator NOT]
parser >> Input 'LPAREN' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN INT_LITERAL]
parser >> Input 'EQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'EQ', pending reduce 11
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression EQ]
parser >> Input 'INT_LITERAL' with pending reduce 11
parser >> Reduce 11 [assignment_operator ::= EQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 47.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN]
parser >> Input 'NOT' in state 33
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN NOT]
parser >> Input 'LPAREN' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 33.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN unary_operator LPAREN]
parser >> Input 'FLOAT' in state 4
parser >> Shift 'FLOAT', pending reduce 50
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN unary_operator LPAREN FLOAT]
parser >> Input 'LONG' with pending reduce 50
parser >> Reduce 50 [type_specifier ::= FLOAT] without external action, pop back to state 4.
parser >> ... then shift 'type_specifier', go to state 70
parser >> Shift 'LONG', pending reduce 47
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN unary_operator LPAREN type_specifier LONG]
parser >> Input 'RPAREN' with pending reduce 47
parser >> Reduce 47 [type_specifier ::= LONG] without external action, pop back to state 70.
parser >> ... then shift 'type_specifier', pending reduce 64
parser >> Reduce 64 [specifier_qualifier_list ::= specifier_qualifier_list type_specifier] without external action, pop back to state 4.
parser >> ... then shift 'specifier_qualifier_list', go to state 70
parser >> Reduce 67 [type_name ::= specifier_qualifier_list] without external action, pop back to state 4.
parser >> ... then shift 'type_name', go to state 172
parser >> Shift 'RPAREN', go to state 86
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN unary_operator LPAREN type_name RPAREN]
parser >> Input 'INT_LITERAL' in state 86
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN unary_operator LPAREN type_name RPAREN INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 86.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 86.
parser >> ... then shift 'unary_expression', pending reduce 90
parser >> Reduce 90 [cast_expression ::= LPAREN type_name RPAREN cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'cast_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN cast_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN cast_expression MOD INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ]
parser >> Input 'INT_LITERAL' in state 68
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 68.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 68.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ unary_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ unary_expression MOD INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 68.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV]
parser >> Input 'LPAREN' in state 88
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN]
parser >> Input 'LPAREN' in state 4
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN LPAREN]
parser >> Input 'UNSIGNED' in state 4
parser >> Shift 'UNSIGNED', pending reduce 49
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN LPAREN UNSIGNED]
parser >> Input 'INT' with pending reduce 49
parser >> Reduce 49 [type_specifier ::= UNSIGNED] without external action, pop back to state 4.
parser >> ... then shift 'type_specifier', go to state 70
parser >> Shift 'INT', pending reduce 46
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN LPAREN type_specifier INT]
parser >> Input 'RPAREN' with pending reduce 46
parser >> Reduce 46 [type_specifier ::= INT] without external action, pop back to state 70.
parser >> ... then shift 'type_specifier', pending reduce 64
parser >> Reduce 64 [specifier_qualifier_list ::= specifier_qualifier_list type_specifier] without external action, pop back to state 4.
parser >> ... then shift 'specifier_qualifier_list', go to state 70
parser >> Reduce 67 [type_name ::= specifier_qualifier_list] without external action, pop back to state 4.
parser >> ... then shift 'type_name', go to state 172
parser >> Shift 'RPAREN', go to state 86
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN LPAREN type_name RPAREN]
parser >> Input 'INT_LITERAL' in state 86
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN LPAREN type_name RPAREN INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 86.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 86.
parser >> ... then shift 'unary_expression', pending reduce 90
parser >> Reduce 90 [cast_expression ::= LPAREN type_name RPAREN cast_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN and_expression AND]
parser >> Input 'NOT' in state 64
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN and_expression AND NOT]
parser >> Input 'NOT' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN and_expression AND unary_operator NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN and_expression AND unary_operator unary_operator INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR]
parser >> Input 'INT_LITERAL' in state 57
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 57.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR]
parser >> Input 'SUB' in state 57
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR SUB]
parser >> Input 'SUB' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 57.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR unary_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR unary_operator unary_operator INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR additive_expression ADD INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN inclusive_or_expression OR exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION]
parser >> Input 'STAR' in state 38
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 38.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET]
parser >> Input 'NOT' in state 40
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET NOT]
parser >> Input 'TILDE' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 40.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET unary_operator TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET unary_operator unary_operator INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET equality_expression EQEQ]
parser >> Input 'NAME' in state 68
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET equality_expression EQEQ NAME]
parser >> Input 'XOR' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 68.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 68.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 68.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 68.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 68.
parser >> ... then shift 'relational_expression', go to state 111
parser >> Reduce 107 [equality_expression ::= equality_expression EQEQ relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'conditional_expression', go to state 153
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET conditional_expression COMMA]
parser >> Input 'INT_LITERAL' in state 48
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET conditional_expression COMMA INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 48.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 48.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET conditional_expression COMMA cast_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET conditional_expression COMMA cast_expression DIV INT_LITERAL]
parser >> Input 'RBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 48.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 48.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 48.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 48.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 48.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 48.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'conditional_expression', pending reduce 124
parser >> Reduce 124 [expression ::= expression COMMA assignment_expression] without external action, pop back to state 40.
parser >> ... then shift 'expression', go to state 153
parser >> Shift 'RBRACKET', pending reduce 76
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION unary_operator primary_expression LBRACKET expression RBRACKET]
parser >> Input 'ADD' with pending reduce 76
parser >> Reduce 76 [postfix_expression ::= postfix_expression LBRACKET expression RBRACKET] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION additive_expression ADD INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'conditional_expression', go to state 140
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA]
parser >> Input 'INT_LITERAL' in state 48
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 48.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 48.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 48.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 48.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN]
parser >> Input 'INT_LITERAL' in state 33
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ]
parser >> Input 'INT_LITERAL' in state 67
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 67.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB]
parser >> Input 'AND' in state 84
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 84.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB unary_operator INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD]
parser >> Input 'NOT' in state 85
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD NOT]
parser >> Input 'AND' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 85.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator AND]
parser >> Input 'LPAREN' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN]
parser >> Input 'AND' in state 4
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN AND]
parser >> Input 'NAME' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 4.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN unary_operator NAME]
parser >> Input 'GT' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT additive_expression SUB]
parser >> Input 'AND' in state 84
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT additive_expression SUB AND]
parser >> Input 'SUB' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 84.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT additive_expression SUB unary_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT additive_expression SUB unary_operator unary_operator INT_LITERAL]
parser >> Input 'ADDADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'ADDADD', pending reduce 81
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN relational_expression GT additive_expression SUB unary_operator unary_operator primary_expression ADDADD]
parser >> Input 'EQEQ' with pending reduce 81
parser >> Reduce 81 [postfix_expression ::= postfix_expression ADDADD] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ]
parser >> Input 'INT_LITERAL' in state 68
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 68.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 68.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET cast_expression DIV]
parser >> Input 'NAME' in state 88
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET cast_expression DIV NAME]
parser >> Input 'SUB' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 40.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET]
parser >> Input 'STAR' in state 40
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 40.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_operator INT_LITERAL]
parser >> Input 'EQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'EQ', pending reduce 11
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression EQ]
parser >> Input 'SUBSUB' with pending reduce 11
parser >> Reduce 11 [assignment_operator ::= EQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'SUBSUB', go to state 95
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression assignment_operator SUBSUB]
parser >> Input 'INT_LITERAL' in state 95
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression assignment_operator SUBSUB INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 95.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 95.
parser >> ... then shift 'unary_expression', pending reduce 85
parser >> Reduce 85 [unary_expression ::= SUBSUB unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 47.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression assignment_operator equality_expression NOTEQ]
parser >> Input 'INT_LITERAL' in state 67
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression assignment_operator equality_expression NOTEQ INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 67.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 47.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 47.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression assignment_operator logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[declaration_specifiers direct_declarator LBRACKET primary_expression LPAREN relational_expression GT LPAREN unary_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR primary_expression LPAREN primary_expression LBRACKET unary_operator primary_expression LBRACKET and_expression AND relational_expression LT unary_operator unary_operator LPAREN expression COMMA unary_expression assignment_operator equality_expression NOTEQ LPAREN additive_expression ADD unary_expression MOD primary_expression LBRACKET exclusive_or_expression XOR unary_expression DIV primary_expression LPAREN inclusive_or_expression OR LPAREN unary_operator unary_operator unary_operator unary_operator LPAREN unary_expression assignment_operator primary_expression LPAREN equality_expression EQEQ multiplicative_expression DIV LPAREN logical_or_expression QUESTION conditional_expression COMMA relational_expression GT primary_expression LPAREN equality_expression NOTEQ unary_expression DIV primary_expression LBRACKET additive_expression ADD unary_operator unary_operator LPAREN equality_expression EQEQ unary_expression DIV primary_expression LBRACKET additive_expression SUB primary_expression LBRACKET unary_expression assignment_operator logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Stack Overflow!
parser >> Popping additive_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping assignment_operator
parser >> Popping unary_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping SUB
parser >> Popping additive_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping DIV
parser >> Popping unary_expression
parser >> Popping EQEQ
parser >> Popping equality_expression
parser >> Popping LPAREN
parser >> Popping unary_operator
parser >> Popping unary_operator
parser >> Popping ADD
parser >> Popping additive_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping DIV
parser >> Popping unary_expression
parser >> Popping NOTEQ
parser >> Popping equality_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping GT
parser >> Popping relational_expression
parser >> Popping COMMA
parser >> Popping conditional_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping LPAREN
parser >> Popping DIV
parser >> Popping multiplicative_expression
parser >> Popping EQEQ
parser >> Popping equality_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping assignment_operator
parser >> Popping unary_expression
parser >> Popping LPAREN
parser >> Popping unary_operator
parser >> Popping unary_operator
parser >> Popping unary_operator
parser >> Popping unary_operator
parser >> Popping LPAREN
parser >> Popping OR
parser >> Popping inclusive_or_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping DIV
parser >> Popping unary_expression
parser >> Popping XOR
parser >> Popping exclusive_or_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping MOD
parser >> Popping unary_expression
parser >> Popping ADD
parser >> Popping additive_expression
parser >> Popping LPAREN
parser >> Popping NOTEQ
parser >> Popping equality_expression
parser >> Popping assignment_operator
parser >> Popping unary_expression
parser >> Popping COMMA
parser >> Popping expression
parser >> Popping LPAREN
parser >> Popping unary_operator
parser >> Popping unary_operator
parser >> Popping LT
parser >> Popping relational_expression
parser >> Popping AND
parser >> Popping and_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping unary_operator
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping XOR
parser >> Popping exclusive_or_expression
parser >> Popping COMMA
parser >> Popping conditional_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping unary_operator
parser >> Popping LPAREN
parser >> Popping GT
parser >> Popping relational_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping LBRACKET
parser >> Popping direct_declarator
parser >> Popping declaration_specifiers
parser >> Return. Stack=]
parser >> Input 'STRUCT' in state 0
parser >> Shift 'STRUCT', pending reduce 29
parser >> Return. Stack=[STRUCT]
parser >> Input 'LBRACE' with pending reduce 29
parser >> Reduce 29 [struct_or_union ::= STRUCT] without external action, pop back to state 0.
parser >> ... then shift 'struct_or_union', go to state 154
parser >> Shift 'LBRACE', go to state 71
parser >> Return. Stack=[struct_or_union LBRACE]
parser >> Input 'LONG' in state 71
parser >> Shift 'LONG', pending reduce 47
parser >> Return. Stack=[struct_or_union LBRACE LONG]
parser >> Input 'STAR' with pending reduce 47
parser >> Reduce 47 [type_specifier ::= LONG] without external action, pop back to state 71.
parser >> ... then shift 'type_specifier', go to state 63
parser >> Shift 'STAR', go to state 100
parser >> Return. Stack=[struct_or_union LBRACE type_specifier STAR]
parser >> Input 'STAR' in state 100
parser >> Shift 'STAR', go to state 100
parser >> Return. Stack=[struct_or_union LBRACE type_specifier STAR STAR]
parser >> Input 'LPAREN' in state 100
parser >> Reduce 60 [pointer ::= STAR] without external action, pop back to state 100.
parser >> ... then shift 'pointer', pending reduce 62
parser >> Reduce 62 [pointer ::= STAR pointer] without external action, pop back to state 63.
parser >> ... then shift 'pointer', go to state 106
parser >> Shift 'LPAREN', go to state 99
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN]
parser >> Input 'LPAREN' in state 99
parser >> Shift 'LPAREN', go to state 99
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN]
parser >> Input 'STAR' in state 99
parser >> Shift 'STAR', go to state 100
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN STAR]
parser >> Input 'CONST' in state 100
parser >> Shift 'CONST', pending reduce 55
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN STAR CONST]
parser >> Input 'LPAREN' with pending reduce 55
parser >> Reduce 55 [type_qualifier ::= CONST] without external action, pop back to state 100.
parser >> ... then shift 'type_qualifier', go to state 102
parser >> Reduce 59 [pointer ::= STAR type_qualifier_list] without external action, pop back to state 99.
parser >> ... then shift 'pointer', go to state 106
parser >> Shift 'LPAREN', go to state 99
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN]
parser >> Input 'NAME' in state 99
parser >> Shift 'NAME', pending reduce 0
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN NAME]
parser >> Input 'LBRACKET' with pending reduce 0
parser >> Reduce 0 [direct_declarator ::= NAME], pop back to state 99.
parser >> ... then shift 'direct_declarator', go to state 135
parser >> Shift 'LBRACKET', go to state 41
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET]
parser >> Input 'INT_LITERAL' in state 41
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 41.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 41.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 41.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 41.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 41.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 41.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression NOTEQ]
parser >> Input 'INT_LITERAL' in state 67
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression NOTEQ INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 67.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression NOTEQ unary_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression NOTEQ unary_expression MOD INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 41.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ]
parser >> Input 'INT_LITERAL' in state 68
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 68.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ primary_expression LBRACKET INT_LITERAL]
parser >> Input 'RBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'conditional_expression', go to state 153
parser >> Shift 'RBRACKET', pending reduce 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ primary_expression LBRACKET conditional_expression RBRACKET]
parser >> Input 'LPAREN' with pending reduce 76
parser >> Reduce 76 [postfix_expression ::= postfix_expression LBRACKET expression RBRACKET] without external action, pop back to state 68.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN]
parser >> Input 'NAME' in state 33
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN NAME]
parser >> Input 'COMMA' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'COMMA', go to state 46
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA]
parser >> Input 'INT_LITERAL' in state 46
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 46.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 46.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 46.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 46.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 46.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 46.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 46.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 46.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND]
parser >> Input 'STAR' in state 64
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND STAR]
parser >> Input 'LPAREN' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN]
parser >> Input 'INT' in state 4
parser >> Shift 'INT', pending reduce 46
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN INT]
parser >> Input 'LBRACKET' with pending reduce 46
parser >> Reduce 46 [type_specifier ::= INT] without external action, pop back to state 4.
parser >> ... then shift 'type_specifier', go to state 70
parser >> Shift 'LBRACKET', go to state 43
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET]
parser >> Input 'NAME' in state 43
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET NAME]
parser >> Input 'OR' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 43.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 43.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 43.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 43.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 43.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 43.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 43.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 43.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 43.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR]
parser >> Input 'NAME' in state 57
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR NAME]
parser >> Input 'OR' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 57.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 43.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR]
parser >> Input 'TILDE' in state 57
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 57.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR unary_operator INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 43.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR]
parser >> Input 'INT_LITERAL' in state 57
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 57.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR unary_expression DIV]
parser >> Input 'NOT' in state 88
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR unary_expression DIV NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 88.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR unary_expression DIV unary_operator INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR additive_expression SUB INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 43.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR]
parser >> Input 'INT_LITERAL' in state 57
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 57.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR relational_expression GT]
parser >> Input 'NAME' in state 75
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR relational_expression GT NAME]
parser >> Input 'AND' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND]
parser >> Input 'ADD' in state 64
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADD]
parser >> Input 'NAME' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND unary_operator NAME]
parser >> Input 'ADD' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD]
parser >> Input 'AND' in state 85
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 85.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD unary_operator INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD unary_expression STAR]
parser >> Input 'ADD' in state 89
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD unary_expression STAR ADD]
parser >> Input 'NAME' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD unary_expression STAR unary_operator NAME]
parser >> Input 'MOD' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 85.
parser >> ... then shift 'multiplicative_expression', go to state 114
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD multiplicative_expression MOD]
parser >> Input 'AND' in state 87
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD multiplicative_expression MOD AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 87.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD multiplicative_expression MOD unary_operator INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD multiplicative_expression MOD unary_operator primary_expression LPAREN]
parser >> Input 'INT_LITERAL' in state 33
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD multiplicative_expression MOD unary_operator primary_expression LPAREN INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'RPAREN', pending reduce 77
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression ADD multiplicative_expression MOD unary_operator primary_expression LPAREN conditional_expression RPAREN]
parser >> Input 'SUB' with pending reduce 77
parser >> Reduce 77 [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 85.
parser >> ... then shift 'multiplicative_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB]
parser >> Input 'LPAREN' in state 84
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN additive_expression SUB INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN additive_expression SUB unary_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN additive_expression SUB unary_expression DIV INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'multiplicative_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'conditional_expression', go to state 152
parser >> Shift 'RPAREN', pending reduce 74
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB LPAREN conditional_expression RPAREN]
parser >> Input 'STAR' with pending reduce 74
parser >> Reduce 74 [primary_expression ::= LPAREN expression RPAREN] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB unary_expression STAR]
parser >> Input 'TILDE' in state 89
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB unary_expression STAR TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB unary_expression STAR unary_operator INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'multiplicative_expression', go to state 113
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB multiplicative_expression STAR]
parser >> Input 'INT_LITERAL' in state 89
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND additive_expression SUB multiplicative_expression STAR INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 89.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'multiplicative_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND]
parser >> Input 'ADDADD' in state 64
parser >> Shift 'ADDADD', go to state 96
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD]
parser >> Input 'ADD' in state 96
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD ADD]
parser >> Input 'LPAREN' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 96.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD unary_operator LPAREN]
parser >> Input 'CONST' in state 4
parser >> Shift 'CONST', pending reduce 55
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD unary_operator LPAREN CONST]
parser >> Input 'STAR' with pending reduce 55
parser >> Reduce 55 [type_qualifier ::= CONST] without external action, pop back to state 4.
parser >> ... then shift 'type_qualifier', go to state 70
parser >> Shift 'STAR', go to state 100
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD unary_operator LPAREN type_qualifier STAR]
parser >> Input 'RPAREN' in state 100
parser >> Reduce 60 [pointer ::= STAR] without external action, pop back to state 70.
parser >> ... then shift 'pointer', go to state 107
parser >> Reduce 195 [abstract_declarator ::= pointer] without external action, pop back to state 70.
parser >> ... then shift 'abstract_declarator', pending reduce 68
parser >> Reduce 68 [type_name ::= specifier_qualifier_list abstract_declarator] without external action, pop back to state 4.
parser >> ... then shift 'type_name', go to state 172
parser >> Shift 'RPAREN', go to state 86
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD unary_operator LPAREN type_name RPAREN]
parser >> Input 'INT_LITERAL' in state 86
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND ADDADD unary_operator LPAREN type_name RPAREN INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 86.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 86.
parser >> ... then shift 'unary_expression', pending reduce 90
parser >> Reduce 90 [cast_expression ::= LPAREN type_name RPAREN cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'cast_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 96.
parser >> ... then shift 'unary_expression', pending reduce 84
parser >> Reduce 84 [unary_expression ::= ADDADD unary_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND equality_expression EQEQ]
parser >> Input 'AND' in state 68
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND equality_expression EQEQ AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 68.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR and_expression AND equality_expression EQEQ unary_operator INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 68.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 68.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 68.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 68.
parser >> ... then shift 'relational_expression', go to state 111
parser >> Reduce 107 [equality_expression ::= equality_expression EQEQ relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR]
parser >> Input 'STAR' in state 59
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 59.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR unary_operator INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR unary_expression STAR]
parser >> Input 'INT_LITERAL' in state 89
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR unary_expression STAR INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 89.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 59.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR equality_expression NOTEQ]
parser >> Input 'SUB' in state 67
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR equality_expression NOTEQ SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR equality_expression NOTEQ unary_operator INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR equality_expression NOTEQ additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET inclusive_or_expression OR exclusive_or_expression XOR equality_expression NOTEQ additive_expression SUB INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 43.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 43.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 43.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION primary_expression LPAREN]
parser >> Input 'TILDE' in state 33
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION primary_expression LPAREN TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 33.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION primary_expression LPAREN unary_operator INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'RPAREN', pending reduce 77
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION primary_expression LPAREN conditional_expression RPAREN]
parser >> Input 'STAR' with pending reduce 77
parser >> Reduce 77 [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN] without external action, pop back to state 38.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION cast_expression STAR]
parser >> Input 'AND' in state 89
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION cast_expression STAR AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION cast_expression STAR unary_operator INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND]
parser >> Input 'INT_LITERAL' in state 64
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND INT_LITERAL]
parser >> Input 'LT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 64.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'LT', go to state 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT]
parser >> Input 'ADD' in state 76
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT ADD]
parser >> Input 'TILDE' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 76.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT unary_operator TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT unary_operator unary_operator INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 76.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 76.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression ADD INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression ADD unary_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression ADD unary_expression DIV INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 85.
parser >> ... then shift 'multiplicative_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 76.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression ADD INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 76.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION and_expression AND relational_expression LT additive_expression SUB INT_LITERAL]
parser >> Input 'COLON' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 76.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 76.
parser >> ... then shift 'shift_expression', go to state 147
parser >> Reduce 102 [relational_expression ::= relational_expression LT shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'conditional_expression', go to state 140
parser >> Shift 'COLON', go to state 51
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON]
parser >> Input 'INT_LITERAL' in state 51
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 51.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 51.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON unary_expression DIV]
parser >> Input 'INT_LITERAL' in state 88
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON unary_expression DIV INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 51.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 51.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET and_expression AND]
parser >> Input 'NOT' in state 64
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET and_expression AND NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET and_expression AND unary_operator INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET and_expression AND additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET and_expression AND additive_expression SUB INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR]
parser >> Input 'LPAREN' in state 59
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN]
parser >> Input 'SUB' in state 4
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN SUB]
parser >> Input 'AND' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 4.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN unary_operator AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN unary_operator unary_operator INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND]
parser >> Input 'STAR' in state 64
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET INT_LITERAL]
parser >> Input 'EQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'EQ', pending reduce 11
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression EQ]
parser >> Input 'SUB' with pending reduce 11
parser >> Reduce 11 [assignment_operator ::= EQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 47.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_operator INT_LITERAL]
parser >> Input 'MODEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'MODEQ', pending reduce 14
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression MODEQ]
parser >> Input 'SUB' with pending reduce 14
parser >> Reduce 14 [assignment_operator ::= MODEQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 47.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_operator INT_LITERAL]
parser >> Input 'MODEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'MODEQ', pending reduce 14
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression MODEQ]
parser >> Input 'INT_LITERAL' with pending reduce 14
parser >> Reduce 14 [assignment_operator ::= MODEQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 47.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN]
parser >> Input 'NAME' in state 33
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN NAME]
parser >> Input 'STAR' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN cast_expression STAR]
parser >> Input 'INT_LITERAL' in state 89
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN cast_expression STAR INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 89.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'COMMA', go to state 46
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA]
parser >> Input 'INT_LITERAL' in state 46
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 46.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 46.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 46.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA cast_expression STAR]
parser >> Input 'INT_LITERAL' in state 89
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA cast_expression STAR INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 89.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 46.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 46.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 46.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 46.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 46.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ]
parser >> Input 'STAR' in state 67
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA equality_expression NOTEQ unary_operator INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 46.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 46.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 46.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN conditional_expression COMMA exclusive_or_expression XOR additive_expression ADD INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 46.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 46.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 46.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 46.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 46.
parser >> ... then shift 'conditional_expression', pending reduce 70
parser >> Reduce 70 [argument_expression_list ::= argument_expression_list COMMA assignment_expression] without external action, pop back to state 33.
parser >> ... then shift 'argument_expression_list', go to state 134
parser >> Shift 'RPAREN', pending reduce 77
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET unary_expression assignment_operator unary_expression assignment_operator unary_expression assignment_operator primary_expression LPAREN argument_expression_list RPAREN]
parser >> Input 'RBRACKET' with pending reduce 77
parser >> Reduce 77 [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN] without external action, pop back to state 47.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 47.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 47.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 47.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'conditional_expression', pending reduce 122
parser >> Reduce 122 [assignment_expression ::= unary_expression assignment_operator assignment_expression] without external action, pop back to state 47.
parser >> ... then shift 'assignment_expression', pending reduce 122
parser >> Reduce 122 [assignment_expression ::= unary_expression assignment_operator assignment_expression] without external action, pop back to state 47.
parser >> ... then shift 'assignment_expression', pending reduce 122
parser >> Reduce 122 [assignment_expression ::= unary_expression assignment_operator assignment_expression] without external action, pop back to state 40.
parser >> ... then shift 'assignment_expression', go to state 153
parser >> Shift 'RBRACKET', pending reduce 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND unary_operator primary_expression LBRACKET assignment_expression RBRACKET]
parser >> Input 'GTEQ' with pending reduce 76
parser >> Reduce 76 [postfix_expression ::= postfix_expression LBRACKET expression RBRACKET] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GTEQ', go to state 73
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ]
parser >> Input 'LPAREN' in state 73
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression ADD INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression SUB]
parser >> Input 'AND' in state 84
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression SUB AND]
parser >> Input 'LPAREN' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 84.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression SUB unary_operator LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression SUB unary_operator LPAREN INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 4.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 4.
parser >> ... then shift 'conditional_expression', go to state 152
parser >> Shift 'RPAREN', pending reduce 74
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR additive_expression SUB unary_operator LPAREN conditional_expression RPAREN]
parser >> Input 'XOR' with pending reduce 74
parser >> Reduce 74 [primary_expression ::= LPAREN expression RPAREN] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR]
parser >> Input 'NAME' in state 59
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR NAME]
parser >> Input 'EQEQ' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ]
parser >> Input 'ADD' in state 68
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ ADD]
parser >> Input 'NOT' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 68.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator unary_operator INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 68.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 68.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 68.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 68.
parser >> ... then shift 'relational_expression', go to state 111
parser >> Reduce 107 [equality_expression ::= equality_expression EQEQ relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression NOTEQ]
parser >> Input 'NOT' in state 67
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression NOTEQ NOT]
parser >> Input 'NAME' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression NOTEQ unary_operator NAME]
parser >> Input 'SUB' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression NOTEQ additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression NOTEQ additive_expression SUB INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ]
parser >> Input 'ADD' in state 68
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ ADD]
parser >> Input 'INT_LITERAL' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 68.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN]
parser >> Input 'INT_LITERAL' in state 33
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN INT_LITERAL]
parser >> Input 'LT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'LT', go to state 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN relational_expression LT]
parser >> Input 'INT_LITERAL' in state 76
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN relational_expression LT INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 76.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 76.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 76.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 76.
parser >> ... then shift 'shift_expression', go to state 147
parser >> Reduce 102 [relational_expression ::= relational_expression LT shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN relational_expression GT INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR]
parser >> Input 'AND' in state 57
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 57.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR unary_operator INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR unary_expression MOD]
parser >> Input 'AND' in state 87
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR unary_expression MOD AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 87.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR unary_expression MOD unary_operator INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR multiplicative_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR multiplicative_expression MOD INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR additive_expression SUB]
parser >> Input 'NAME' in state 84
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR additive_expression SUB NAME]
parser >> Input 'ADD' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR additive_expression ADD INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR additive_expression ADD]
parser >> Input 'INT_LITERAL' in state 85
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR additive_expression ADD INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 85.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR]
parser >> Input 'NOT' in state 57
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR NOT]
parser >> Input 'STAR' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 57.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR unary_operator STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN inclusive_or_expression OR unary_operator unary_operator INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'COMMA', go to state 46
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA]
parser >> Input 'INT_LITERAL' in state 46
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 46.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN]
parser >> Input 'STAR' in state 33
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN STAR]
parser >> Input 'STAR' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 33.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN unary_operator STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN unary_operator unary_operator INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN cast_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN cast_expression MOD INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 33.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN inclusive_or_expression OR]
parser >> Input 'INT_LITERAL' in state 57
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN inclusive_or_expression OR INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 57.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION cast_expression MOD]
parser >> Input 'AND' in state 87
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION cast_expression MOD AND]
parser >> Input 'NAME' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 87.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION cast_expression MOD unary_operator NAME]
parser >> Input 'GT' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION relational_expression GT INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR]
parser >> Input 'LPAREN' in state 57
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN]
parser >> Input 'INT_LITERAL' in state 4
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN INT_LITERAL]
parser >> Input 'ANDEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 4.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'ANDEQ', pending reduce 19
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression ANDEQ]
parser >> Input 'INT_LITERAL' with pending reduce 19
parser >> Reduce 19 [assignment_operator ::= ANDEQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator INT_LITERAL]
parser >> Input 'ADD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 47.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'ADD', go to state 85
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator additive_expression ADD]
parser >> Input 'STAR' in state 85
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator additive_expression ADD STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 85.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator additive_expression ADD unary_operator INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 85.
parser >> ... then shift 'unary_expression', go to state 114
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator additive_expression ADD unary_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator additive_expression ADD unary_expression MOD INT_LITERAL]
parser >> Input 'OR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 85.
parser >> ... then shift 'multiplicative_expression', go to state 114
parser >> Reduce 96 [additive_expression ::= additive_expression ADD multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 47.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 47.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 47.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Shift 'OR', go to state 57
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR]
parser >> Input 'ADD' in state 57
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR ADD]
parser >> Input 'ADD' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 57.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'ADD', pending reduce 7
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR unary_operator ADD]
parser >> Input 'INT_LITERAL' with pending reduce 7
parser >> Reduce 7 [unary_operator ::= ADD] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR unary_operator unary_operator INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR unary_expression STAR]
parser >> Input 'SUB' in state 89
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR unary_expression STAR SUB]
parser >> Input 'NAME' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator inclusive_or_expression OR unary_expression STAR unary_operator NAME]
parser >> Input 'QUESTION' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 57.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 57.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 57.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 57.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 57.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 57.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 57.
parser >> ... then shift 'exclusive_or_expression', go to state 187
parser >> Reduce 114 [inclusive_or_expression ::= inclusive_or_expression OR exclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET]
parser >> Input 'STAR' in state 40
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 40.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator primary_expression LBRACKET INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator primary_expression LBRACKET additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator primary_expression LBRACKET additive_expression SUB INT_LITERAL]
parser >> Input 'RBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'conditional_expression', go to state 153
parser >> Shift 'RBRACKET', pending reduce 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator primary_expression LBRACKET conditional_expression RBRACKET]
parser >> Input 'LPAREN' with pending reduce 76
parser >> Reduce 76 [postfix_expression ::= postfix_expression LBRACKET expression RBRACKET] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN]
parser >> Input 'INT_LITERAL' in state 33
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND]
parser >> Input 'SUB' in state 64
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 64.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND unary_operator INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND additive_expression SUB INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN and_expression AND relational_expression GT INT_LITERAL]
parser >> Input 'RPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'RPAREN', pending reduce 77
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET unary_operator postfix_expression LPAREN conditional_expression RPAREN]
parser >> Input 'QUESTION' with pending reduce 77
parser >> Reduce 77 [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'DIV' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'DIV', go to state 88
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION cast_expression DIV]
parser >> Input 'NAME' in state 88
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION cast_expression DIV NAME]
parser >> Input 'LPAREN' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 88.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION cast_expression DIV primary_expression LPAREN]
parser >> Input 'NAME' in state 33
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION cast_expression DIV primary_expression LPAREN NAME]
parser >> Input 'RPAREN' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 33.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 33.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 33.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 33.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 33.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 33.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 33.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 33.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 33.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 33.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 33.
parser >> ... then shift 'conditional_expression', go to state 134
parser >> Shift 'RPAREN', pending reduce 77
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION cast_expression DIV primary_expression LPAREN conditional_expression RPAREN]
parser >> Input 'AND' with pending reduce 77
parser >> Reduce 77 [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN] without external action, pop back to state 88.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 88.
parser >> ... then shift 'unary_expression', pending reduce 93
parser >> Reduce 93 [multiplicative_expression ::= multiplicative_expression DIV cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND]
parser >> Input 'INT_LITERAL' in state 64
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 64.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION]
parser >> Input 'AND' in state 38
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 38.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION unary_operator INT_LITERAL]
parser >> Input 'LPAREN' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LPAREN', go to state 33
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION unary_operator primary_expression LPAREN]
parser >> Input 'RPAREN' in state 33
parser >> Shift 'RPAREN', pending reduce 78
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION unary_operator primary_expression LPAREN RPAREN]
parser >> Input 'MOD' with pending reduce 78
parser >> Reduce 78 [postfix_expression ::= postfix_expression LPAREN RPAREN] without external action, pop back to state 90.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION cast_expression MOD]
parser >> Input 'TILDE' in state 87
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION cast_expression MOD TILDE]
parser >> Input 'SUB' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 87.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION cast_expression MOD unary_operator SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 90.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION cast_expression MOD unary_operator unary_operator INT_LITERAL]
parser >> Input 'COLON' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'conditional_expression', go to state 140
parser >> Shift 'COLON', go to state 51
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON]
parser >> Input 'INT_LITERAL' in state 51
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 51.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 51.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 51.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 51.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 51.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 51.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ]
parser >> Input 'SUB' in state 67
parser >> Shift 'SUB', pending reduce 8
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ SUB]
parser >> Input 'INT_LITERAL' with pending reduce 8
parser >> Reduce 8 [unary_operator ::= SUB] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET cast_expression STAR]
parser >> Input 'AND' in state 89
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET cast_expression STAR AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET cast_expression STAR unary_operator INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 40.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET exclusive_or_expression XOR equality_expression EQEQ]
parser >> Input 'INT_LITERAL' in state 68
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET exclusive_or_expression XOR equality_expression EQEQ INT_LITERAL]
parser >> Input 'GT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 68.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 68.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 68.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 68.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 68.
parser >> ... then shift 'relational_expression', go to state 111
parser >> Shift 'GT', go to state 75
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET exclusive_or_expression XOR equality_expression EQEQ relational_expression GT]
parser >> Input 'INT_LITERAL' in state 75
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET exclusive_or_expression XOR equality_expression EQEQ relational_expression GT INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 75.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 75.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 75.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 75.
parser >> ... then shift 'shift_expression', go to state 146
parser >> Reduce 103 [relational_expression ::= relational_expression GT shift_expression] without external action, pop back to state 68.
parser >> ... then shift 'relational_expression', go to state 111
parser >> Reduce 107 [equality_expression ::= equality_expression EQEQ relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION]
parser >> Input 'NOT' in state 38
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION NOT]
parser >> Input 'NAME' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 38.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION unary_operator NAME]
parser >> Input 'SUB' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB]
parser >> Input 'LPAREN' in state 84
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN]
parser >> Input 'DOUBLE' in state 4
parser >> Shift 'DOUBLE', pending reduce 51
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN DOUBLE]
parser >> Input 'DOUBLE' with pending reduce 51
parser >> Reduce 51 [type_specifier ::= DOUBLE] without external action, pop back to state 4.
parser >> ... then shift 'type_specifier', go to state 70
parser >> Shift 'DOUBLE', pending reduce 51
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN type_specifier DOUBLE]
parser >> Input 'FLOAT' with pending reduce 51
parser >> Reduce 51 [type_specifier ::= DOUBLE] without external action, pop back to state 70.
parser >> ... then shift 'type_specifier', pending reduce 64
parser >> Reduce 64 [specifier_qualifier_list ::= specifier_qualifier_list type_specifier] without external action, pop back to state 4.
parser >> ... then shift 'specifier_qualifier_list', go to state 70
parser >> Shift 'FLOAT', pending reduce 50
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN specifier_qualifier_list FLOAT]
parser >> Input 'INT' with pending reduce 50
parser >> Reduce 50 [type_specifier ::= FLOAT] without external action, pop back to state 70.
parser >> ... then shift 'type_specifier', pending reduce 64
parser >> Reduce 64 [specifier_qualifier_list ::= specifier_qualifier_list type_specifier] without external action, pop back to state 4.
parser >> ... then shift 'specifier_qualifier_list', go to state 70
parser >> Shift 'INT', pending reduce 46
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN specifier_qualifier_list INT]
parser >> Input 'INT' with pending reduce 46
parser >> Reduce 46 [type_specifier ::= INT] without external action, pop back to state 70.
parser >> ... then shift 'type_specifier', pending reduce 64
parser >> Reduce 64 [specifier_qualifier_list ::= specifier_qualifier_list type_specifier] without external action, pop back to state 4.
parser >> ... then shift 'specifier_qualifier_list', go to state 70
parser >> Shift 'INT', pending reduce 46
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN specifier_qualifier_list INT]
parser >> Input 'RPAREN' with pending reduce 46
parser >> Reduce 46 [type_specifier ::= INT] without external action, pop back to state 70.
parser >> ... then shift 'type_specifier', pending reduce 64
parser >> Reduce 64 [specifier_qualifier_list ::= specifier_qualifier_list type_specifier] without external action, pop back to state 4.
parser >> ... then shift 'specifier_qualifier_list', go to state 70
parser >> Reduce 67 [type_name ::= specifier_qualifier_list] without external action, pop back to state 4.
parser >> ... then shift 'type_name', go to state 172
parser >> Shift 'RPAREN', go to state 86
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN type_name RPAREN]
parser >> Input 'INT_LITERAL' in state 86
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION additive_expression SUB LPAREN type_name RPAREN INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 86.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 86.
parser >> ... then shift 'unary_expression', pending reduce 90
parser >> Reduce 90 [cast_expression ::= LPAREN type_name RPAREN cast_expression] without external action, pop back to state 84.
parser >> ... then shift 'cast_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 38.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 38.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 38.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 38.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 38.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 38.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 38.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 38.
parser >> ... then shift 'conditional_expression', go to state 140
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA]
parser >> Input 'INT_LITERAL' in state 48
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 48.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 48.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA cast_expression MOD]
parser >> Input 'INT_LITERAL' in state 87
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA cast_expression MOD INT_LITERAL]
parser >> Input 'LT' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 87.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 48.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 48.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 48.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Shift 'LT', go to state 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA relational_expression LT]
parser >> Input 'TILDE' in state 76
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA relational_expression LT TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 76.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA relational_expression LT unary_operator INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 76.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA relational_expression LT unary_expression MOD]
parser >> Input 'TILDE' in state 87
parser >> Shift 'TILDE', pending reduce 9
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA relational_expression LT unary_expression MOD TILDE]
parser >> Input 'INT_LITERAL' with pending reduce 9
parser >> Reduce 9 [unary_operator ::= TILDE] without external action, pop back to state 87.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA relational_expression LT unary_expression MOD unary_operator INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 87.
parser >> ... then shift 'unary_expression', pending reduce 94
parser >> Reduce 94 [multiplicative_expression ::= multiplicative_expression MOD cast_expression] without external action, pop back to state 76.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 76.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 76.
parser >> ... then shift 'shift_expression', go to state 147
parser >> Reduce 102 [relational_expression ::= relational_expression LT shift_expression] without external action, pop back to state 48.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 48.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 48.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 48.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA exclusive_or_expression XOR and_expression AND]
parser >> Input 'INT_LITERAL' in state 64
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA exclusive_or_expression XOR and_expression AND INT_LITERAL]
parser >> Input 'QUESTION' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 64.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 59.
parser >> ... then shift 'and_expression', go to state 189
parser >> Reduce 112 [exclusive_or_expression ::= exclusive_or_expression XOR and_expression] without external action, pop back to state 48.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 48.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Shift 'QUESTION', go to state 38
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION]
parser >> Input 'INT_LITERAL' in state 38
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION INT_LITERAL]
parser >> Input 'MOD' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 38.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 38.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 38.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Shift 'MOD', go to state 87
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD]
parser >> Input 'LPAREN' in state 87
parser >> Shift 'LPAREN', go to state 4
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN]
parser >> Input 'AND' in state 4
parser >> Shift 'AND', pending reduce 5
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN AND]
parser >> Input 'INT_LITERAL' with pending reduce 5
parser >> Reduce 5 [unary_operator ::= AND] without external action, pop back to state 4.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN unary_operator INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 4.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 4.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN additive_expression SUB INT_LITERAL]
parser >> Input 'SUB' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Shift 'SUB', go to state 84
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN additive_expression SUB]
parser >> Input 'INT_LITERAL' in state 84
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN additive_expression SUB INT_LITERAL]
parser >> Input 'AND' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 84.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 84.
parser >> ... then shift 'unary_expression', go to state 113
parser >> Reduce 97 [additive_expression ::= additive_expression SUB multiplicative_expression] without external action, pop back to state 4.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 4.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 4.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 4.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Shift 'AND', go to state 64
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN and_expression AND]
parser >> Input 'INT_LITERAL' in state 64
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN and_expression AND INT_LITERAL]
parser >> Input 'XOR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 64.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 64.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 64.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 64.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 64.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 64.
parser >> ... then shift 'equality_expression', go to state 142
parser >> Reduce 110 [and_expression ::= and_expression AND equality_expression] without external action, pop back to state 4.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 4.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Shift 'XOR', go to state 59
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR]
parser >> Input 'INT_LITERAL' in state 59
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR INT_LITERAL]
parser >> Input 'NOTEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 59.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 59.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 59.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 59.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 59.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ]
parser >> Input 'INT_LITERAL' in state 67
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ INT_LITERAL]
parser >> Input 'LBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 67.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Shift 'LBRACKET', go to state 40
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET]
parser >> Input 'INT_LITERAL' in state 40
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET INT_LITERAL]
parser >> Input 'COMMA' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 40.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 40.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 40.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 40.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 40.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 40.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 40.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 40.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 40.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 40.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 40.
parser >> ... then shift 'conditional_expression', go to state 153
parser >> Shift 'COMMA', go to state 48
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET conditional_expression COMMA]
parser >> Input 'NAME' in state 48
parser >> Shift 'NAME', pending reduce 71
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET conditional_expression COMMA NAME]
parser >> Input 'EQ' with pending reduce 71
parser >> Reduce 71 [primary_expression ::= NAME] without external action, pop back to state 48.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 48.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Shift 'EQ', pending reduce 11
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET conditional_expression COMMA unary_expression EQ]
parser >> Input 'STAR' with pending reduce 11
parser >> Reduce 11 [assignment_operator ::= EQ] without external action, pop back to state 105.
parser >> ... then shift 'assignment_operator', go to state 47
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET conditional_expression COMMA unary_expression assignment_operator STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 47.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET conditional_expression COMMA unary_expression assignment_operator unary_operator INT_LITERAL]
parser >> Input 'RBRACKET' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 47.
parser >> ... then shift 'unary_expression', go to state 105
parser >> Reduce 89 [cast_expression ::= unary_expression] without external action, pop back to state 47.
parser >> ... then shift 'cast_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 47.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 47.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 47.
parser >> ... then shift 'relational_expression', go to state 112
parser >> Reduce 106 [equality_expression ::= relational_expression] without external action, pop back to state 47.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Reduce 109 [and_expression ::= equality_expression] without external action, pop back to state 47.
parser >> ... then shift 'and_expression', go to state 191
parser >> Reduce 111 [exclusive_or_expression ::= and_expression] without external action, pop back to state 47.
parser >> ... then shift 'exclusive_or_expression', go to state 190
parser >> Reduce 113 [inclusive_or_expression ::= exclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'inclusive_or_expression', go to state 188
parser >> Reduce 115 [logical_and_expression ::= inclusive_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_and_expression', go to state 186
parser >> Reduce 117 [logical_or_expression ::= logical_and_expression] without external action, pop back to state 47.
parser >> ... then shift 'logical_or_expression', go to state 141
parser >> Reduce 119 [conditional_expression ::= logical_or_expression] without external action, pop back to state 47.
parser >> ... then shift 'conditional_expression', pending reduce 122
parser >> Reduce 122 [assignment_expression ::= unary_expression assignment_operator assignment_expression] without external action, pop back to state 48.
parser >> ... then shift 'assignment_expression', pending reduce 124
parser >> Reduce 124 [expression ::= expression COMMA assignment_expression] without external action, pop back to state 40.
parser >> ... then shift 'expression', go to state 153
parser >> Shift 'RBRACKET', pending reduce 76
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ primary_expression LBRACKET expression RBRACKET]
parser >> Input 'NOTEQ' with pending reduce 76
parser >> Reduce 76 [postfix_expression ::= postfix_expression LBRACKET expression RBRACKET] without external action, pop back to state 67.
parser >> ... then shift 'postfix_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'NOTEQ', go to state 67
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ]
parser >> Input 'STAR' in state 67
parser >> Shift 'STAR', pending reduce 6
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ STAR]
parser >> Input 'INT_LITERAL' with pending reduce 6
parser >> Reduce 6 [unary_operator ::= STAR] without external action, pop back to state 67.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ unary_operator INT_LITERAL]
parser >> Input 'STAR' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'unary_expression', go to state 115
parser >> Shift 'STAR', go to state 89
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ unary_expression STAR]
parser >> Input 'NOT' in state 89
parser >> Shift 'NOT', pending reduce 10
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ unary_expression STAR NOT]
parser >> Input 'INT_LITERAL' with pending reduce 10
parser >> Reduce 10 [unary_operator ::= NOT] without external action, pop back to state 89.
parser >> ... then shift 'unary_operator', go to state 90
parser >> Shift 'INT_LITERAL', pending reduce 72
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression NOTEQ unary_expression STAR unary_operator INT_LITERAL]
parser >> Input 'EQEQ' with pending reduce 72
parser >> Reduce 72 [primary_expression ::= INT_LITERAL] without external action, pop back to state 90.
parser >> ... then shift 'primary_expression', go to state 109
parser >> Reduce 83 [unary_expression ::= postfix_expression] without external action, pop back to state 90.
parser >> ... then shift 'unary_expression', pending reduce 86
parser >> Reduce 86 [unary_expression ::= unary_operator cast_expression] without external action, pop back to state 89.
parser >> ... then shift 'unary_expression', pending reduce 92
parser >> Reduce 92 [multiplicative_expression ::= multiplicative_expression STAR cast_expression] without external action, pop back to state 67.
parser >> ... then shift 'multiplicative_expression', go to state 115
parser >> Reduce 95 [additive_expression ::= multiplicative_expression] without external action, pop back to state 67.
parser >> ... then shift 'additive_expression', go to state 151
parser >> Reduce 98 [shift_expression ::= additive_expression] without external action, pop back to state 67.
parser >> ... then shift 'shift_expression', go to state 150
parser >> Reduce 101 [relational_expression ::= shift_expression] without external action, pop back to state 67.
parser >> ... then shift 'relational_expression', go to state 110
parser >> Reduce 108 [equality_expression ::= equality_expression NOTEQ relational_expression] without external action, pop back to state 59.
parser >> ... then shift 'equality_expression', go to state 143
parser >> Shift 'EQEQ', go to state 68
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression EQEQ]
parser >> Input 'END_TOKEN' in state 68
parser >> Syntax Error!
parser >> Return. Stack=[struct_or_union LBRACE type_specifier pointer LPAREN LPAREN pointer LPAREN direct_declarator LBRACKET equality_expression EQEQ postfix_expression LPAREN conditional_expression COMMA and_expression AND unary_operator LPAREN type_specifier LBRACKET logical_or_expression QUESTION conditional_expression COLON additive_expression ADD primary_expression LBRACKET exclusive_or_expression XOR LPAREN and_expression AND relational_expression GTEQ LPAREN exclusive_or_expression XOR equality_expression EQEQ unary_operator primary_expression LPAREN conditional_expression COMMA primary_expression LPAREN logical_or_expression QUESTION inclusive_or_expression OR LPAREN unary_expression assignment_operator logical_or_expression QUESTION primary_expression LBRACKET logical_or_expression QUESTION and_expression AND primary_expression LBRACKET logical_or_expression QUESTION conditional_expression COLON equality_expression NOTEQ unary_operator primary_expression LBRACKET logical_or_expression QUESTION logical_or_expression QUESTION conditional_expression COMMA logical_or_expression QUESTION cast_expression MOD LPAREN exclusive_or_expression XOR equality_expression EQEQ]
parser >> Input '$' in state 68
parser >> Syntax Error!
parser >> Fail!
parser >> Popping EQEQ
parser >> Popping equality_expression
parser >> Popping XOR
parser >> Popping exclusive_or_expression
parser >> Popping LPAREN
parser >> Popping MOD
parser >> Popping cast_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping COMMA
parser >> Popping conditional_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping unary_operator
parser >> Popping NOTEQ
parser >> Popping equality_expression
parser >> Popping COLON
parser >> Popping conditional_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping AND
parser >> Popping and_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping assignment_operator
parser >> Popping unary_expression
parser >> Popping LPAREN
parser >> Popping OR
parser >> Popping inclusive_or_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping COMMA
parser >> Popping conditional_expression
parser >> Popping LPAREN
parser >> Popping primary_expression
parser >> Popping unary_operator
parser >> Popping EQEQ
parser >> Popping equality_expression
parser >> Popping XOR
parser >> Popping exclusive_or_expression
parser >> Popping LPAREN
parser >> Popping GTEQ
parser >> Popping relational_expression
parser >> Popping AND
parser >> Popping and_expression
parser >> Popping LPAREN
parser >> Popping XOR
parser >> Popping exclusive_or_expression
parser >> Popping LBRACKET
parser >> Popping primary_expression
parser >> Popping ADD
parser >> Popping additive_expression
parser >> Popping COLON
parser >> Popping conditional_expression
parser >> Popping QUESTION
parser >> Popping logical_or_expression
parser >> Popping LBRACKET
parser >> Popping type_specifier
parser >> Popping LPAREN
parser >> Popping unary_operator
parser >> Popping AND
parser >> Popping and_expression
parser >> Popping COMMA
parser >> Popping conditional_expression
parser >> Popping LPAREN
parser >> Popping postfix_expression
parser >> Popping EQEQ
parser >> Popping equality_expression
parser >> Popping LBRACKET
parser >> Popping direct_declarator
parser >> Popping LPAREN
parser >> Popping pointer
parser >> Popping LPAREN
parser >> Popping LPAREN
parser >> Popping pointer
parser >> Popping type_specifier
parser >> Popping LBRACE
parser >> Popping struct_or_union
parser >> Return. Stack=]
